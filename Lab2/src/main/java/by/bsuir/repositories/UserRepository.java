package by.bsuir.repositories;

import by.bsuir.domain.Order;
import by.bsuir.domain.Role;
import by.bsuir.domain.User;
import by.bsuir.exceptions.ConnectionException;
import lombok.NoArgsConstructor;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@NoArgsConstructor
public class UserRepository {
    private final ProductRepository productRepository = new ProductRepository();
    private final static ConnectionPool pool = ConnectionPool.getInstance();
    private final static String ADD_USER = "INSERT INTO users (name, lastName, email, birthDate, " +
            "registrationDate, balance, password, address, phoneNumber) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
    private final static String GET_USER_BY_EMAIL = "SELECT * FROM users WHERE email = ?";
    private final static String GET_USER_ORDERS = "SELECT * FROM orders JOIN orders_products " +
            "ON orders.id = orders_products.orderId WHERE orders.id = ?";
    private final static String GET_USER_ROLES = "SELECT roles.id, roles.name FROM roles JOIN users_roles ON " +
            "users.id = users_roles.userId WHERE users.id = ?";

    public void persist(User user) throws SQLException, ConnectionException {
        Connection connection = pool.getConnection();
        try (PreparedStatement statement = connection.prepareStatement(ADD_USER, Statement.RETURN_GENERATED_KEYS)) {
            statement.setString(1, user.getName());
            statement.setString(2, user.getLastName());
            statement.setString(3, user.getEmail());
            statement.setDate(4, Date.valueOf(user.getBirthDate()));
            statement.setDate(5, Date.valueOf(user.getRegistrationDate()));
            statement.setBigDecimal(6, user.getBalance());
            statement.setString(7, user.getPassword());
            statement.setString(8, user.getAddress());
            statement.setString(9, user.getPhoneNumber());
            statement.execute();
            ResultSet autoGenerated = statement.getGeneratedKeys();
            if (autoGenerated.next()) {
                user.setId(autoGenerated.getInt(1));
            }
            autoGenerated.close();
        } finally {
            pool.returnConnection(connection);
        }
    }

    public boolean isPresent(String userEmail) throws ConnectionException, SQLException {
        Connection connection = pool.getConnection();
        try (PreparedStatement statement = connection.prepareStatement(GET_USER_BY_EMAIL)) {
            statement.setString(1, userEmail);
            ResultSet set = statement.executeQuery();
            boolean isPresent =  set.next();
            set.close();
            return isPresent;
        } finally {
            pool.returnConnection(connection);
        }
    }

    public Optional<User> getByEmail(String email) throws ConnectionException, SQLException {
        Optional<User> user = Optional.empty();
        Connection connection = pool.getConnection();

        //Get all user info except orders and roles
        try (PreparedStatement statement = connection.prepareStatement(GET_USER_BY_EMAIL)) {
            statement.setString(1, email);
            ResultSet set = statement.executeQuery();
            if (set.next()) {
                user =  Optional.of(User.
                        builder().
                        id(set.getInt("id")).
                        name(set.getString("name")).
                        email(set.getString("email")).
                        birthDate(set.getDate("birthDate").toLocalDate()).
                        registrationDate(set.getDate("registrationDate").toLocalDate()).
                        balance(set.getBigDecimal("balance")).
                        password(set.getString("password")).
                        address(set.getString("address")).
                        phoneNumber(set.getString("phoneNumber")).
                        orders(new ArrayList<>()).
                        roles(new ArrayList<>()).
                        build());
            }
            set.close();
        } finally {
            pool.returnConnection(connection);
        }

        //Get user orders and roles
        if (user.isPresent()) {
            user.get().setOrders(getOrders(user.get().getId()));
            user.get().setRoles(getRoles(user.get().getId()));
        }

        return user;
    }

    public List<Order> getOrders(int userId) throws ConnectionException, SQLException {
        List<Order> result = new ArrayList<>();
        Connection connection = pool.getConnection();
        try (PreparedStatement statement = connection.prepareStatement(GET_USER_ORDERS)) {
            statement.setInt(1, userId);
            ResultSet set = statement.executeQuery();
            while (set.next()) {
                result.add(Order.
                        builder().
                        id(set.getInt("orders.id")).
                        date(set.getDate("date").toLocalDate()).
                        userId(set.getInt("userId")).
                        price(set.getBigDecimal("price")).
                        products(productRepository.getOrderProducts(set.getInt("orders.id"))).
                        build());
            }
            set.close();
        } finally {
            pool.returnConnection(connection);
        }
        return result;
    }

    public List<Role> getRoles(int userId) throws ConnectionException, SQLException {
        List<Role> result = new ArrayList<>();
        Connection connection = pool.getConnection();
        try (PreparedStatement statement = connection.prepareStatement(GET_USER_ROLES)) {
            statement.setInt(1, userId);
            ResultSet set = statement.executeQuery();
            while (set.next()) {
                result.add(Role.
                        builder().
                        id(set.getInt("id")).
                        name(set.getString("name")).
                        build());
            }
            set.close();
        } finally {
            pool.returnConnection(connection);
        }
        return result;
    }
}
